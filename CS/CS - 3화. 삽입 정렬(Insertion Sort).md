# CS - 3화. 삽입 정렬(Insertion Sort)

> `Insertion Sort`는 배열의 모든 요소들을 앞에서부터 차례대로 확인하고, 자기 자신을 이미 정렬된 앞부분에 삽입하는 방식이다.
>
> 모두 먼저와서 줄 서있는데 뒤늦게와서 자기자리 찾아서 들어가는 느낌!?
>



![다운로드 (2)](CS - 3화. 삽입 정렬(Insertion Sort).assets/다운로드 (2).gif)



- 아이고 죄송합니다. 혹시 번호가 어떻게 되세요...?.. 아이고... 아이고...

- 아! 여기 제자린데 들어가도 될까요....☆

  



## 장/단점

- 장점
  - 코드가 간결하다. (알고리즘이 간단하다.)
  - 원소가 정렬되어 있을 수록 매우 효율적이다.
  - `별도의 메모리 공간`을 필요로하지 않는다.
- 안정 정렬(Stable sort)입니다.  
    - 안정정렬이 궁금하면 [이 게시글 중간쯤](https://ashoil.tistory.com/17) 을 참고하세요!
  - [Selection Sort](https://ashoil.tistory.com/17)나 [Bubble Sort](https://ashoil.tistory.com/16)보다 상대적으로 빠르다.
  
  
  
- 단점
  - 평균과 최악의 경우 시간복잡도가 `O(N^2)`로 비효율적이다.
  - 배열의 길이가 길어질수록 비효율적이다.(큰 배열에 사용하기 부적합하다.)





## 코드

```python
def insertSort(x):
    for i in range(1, len(x)):
        j = i - 1
        key = x[i]
        while x[j] > key and j >= 0:
            x[j+1] = x[j]
            j = j - 1
            x[j+1] = key
            print(x)
    return x

x = [5, 7, 4, 2, 6, 8, 1, 3]

--- print ---
# 실제 프린트               # 이렇게 보면 좀 더 이해하기 쉬울지도?
                          # 정렬 된 것 // 나머지
[5, 7, 4, 2, 6, 8, 1, 3]  # --> [5, 7] [4, 2, 6, 8, 1, 3] 7이 자기 위치 찾아감
[4, 5, 7, 2, 6, 8, 1, 3]  # --> [4, 5, 7] [2, 6, 8, 1, 3] 4가 자기 위치 찾아감
[2, 4, 5, 7, 6, 8, 1, 3]  # --> [2, 4, 5, 7] [6, 8, 1, 3] 2가 자기 위치 찾아감
[2, 4, 5, 6, 7, 8, 1, 3]  # --> ......
[2, 4, 5, 6, 7, 8, 1, 3]  
[1, 2, 4, 5, 6, 7, 8, 3]   
[1, 2, 3, 4, 5, 6, 7, 8]  
[1, 2, 3, 4, 5, 6, 7, 8]  # --> 완성!
```



## 시간 복잡도

- 최선의 경우: `O(N2)` : 한번씩만 비교하면 되기 때문에!

  - 배열의 자료를 삽입/제거하는 경우, 매우 우수한 정렬 알고리즘이다.

- 평균, 최악의 경우 : `O(N^2)`  : (n-1) + (n-2) + (n-3) + ... + 3 + 2 + 1 ==> n(n-1)/2

  - 최악의 경우란, 배열이 역으로 정렬되어 있는 경우이다.

  



#### 참고 자료

https://github.com/WooVictory/Ready-For-Tech-Interview/blob/master/Algorithm/%EC%82%BD%EC%9E%85%20%EC%A0%95%EB%A0%AC(Insertion%20Sort).md

https://gaemi606.tistory.com/entry/%EA%B1%B0%ED%92%88%EC%A0%95%EB%A0%ACBubble-sort-%EC%84%A0%ED%83%9D%EC%A0%95%EB%A0%ACSelection-sort



