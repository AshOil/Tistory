# CS - 8화. 계수정렬(Count Sort)

> `Count Sort`는 `계수정렬`처럼 서로 비교하는 것 없이 각각의 요소의 갯수를 count해서 정렬하는 방식



- 각 요소의 갯수를 세어준 후, 이를 누적합으로 나타내 원소가 들어가야할 위치를 표시해 주는 형식이다.

  

![animation of modifying array in counting sort](CS - 8화. 계수 정렬(Count Sort).assets/count1.gif)



![animation of counting sort](CS - 8화. 계수 정렬(Count Sort).assets/count2.gif)





- `temp`에 우선 각 요소의 갯수를 넣어준 후, 이를 누적합으로 바꾼 `Modifide temp`로 바꾼다.

  - 이 때, `Modified temp`는 해당 idx요소가 들어가야 할 위치를 말해준다.

  - 그냥 갯수를 반복하면 되지 왜 이런 식으로 진행할까!?!

    - 그 이유는 바로! 불필요한 순회를 막기위해!

    - [0, 2, 0, 100, 2, 2, 1 ,0] 을 정렬해보자. 중간에 등장한 뜬금없이 큰 100이 있어서 3~99까지 무의미한 순회 발생

    - `숫자 크기`에 시간복잡도가 매우 큰 영향을 받으므로 `비효율적`이라는 것을 알 수 있습니다.

      





## 코드

```python
x = [5, 7, 4, 2, 6, 8, 1, 3, 3, 4, 5, 2, 1, 4, 8, 7]

MAX_NUM = 1000 #입력될 수 있는 숫자의 최대 크기
N = len(x)
temp =[0]*(MAX_NUM+1) # 각 요소의 갯수를 세어준다.
Modifide_temp =[0]*(MAX_NUM+1) # 누적합 항목
for i in range(0, N): temp[x[i]] += 1 # 숫자 세기
Modifide_temp[0] = temp[0] # 누적합 구하기
for i in range(1, MAX_NUM+1):
    Modifide_temp[i] = Modifide_temp[i-1]+temp[i]
#B는 정렬된 결과를 저장하는 배열
B = [0]*(N+1)
for i in range(N-1, -1, -1):
    B[Modifide_temp[x[i]]] = x[i]
    print(B)
    Modifide_temp[x[i]] -= 1 # 해당 칸에 넣었으니 한 칸 씩 당기기
    
----------------------------------

[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0]
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 8]
[0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 7, 0, 8]
[0, 0, 1, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 7, 0, 8]
[0, 0, 1, 0, 2, 0, 0, 0, 0, 4, 0, 0, 0, 0, 7, 0, 8]
[0, 0, 1, 0, 2, 0, 0, 0, 0, 4, 0, 5, 0, 0, 7, 0, 8]
[0, 0, 1, 0, 2, 0, 0, 0, 4, 4, 0, 5, 0, 0, 7, 0, 8]
[0, 0, 1, 0, 2, 0, 3, 0, 4, 4, 0, 5, 0, 0, 7, 0, 8]
[0, 0, 1, 0, 2, 3, 3, 0, 4, 4, 0, 5, 0, 0, 7, 0, 8]
[0, 1, 1, 0, 2, 3, 3, 0, 4, 4, 0, 5, 0, 0, 7, 0, 8]
[0, 1, 1, 0, 2, 3, 3, 0, 4, 4, 0, 5, 0, 0, 7, 8, 8]
[0, 1, 1, 0, 2, 3, 3, 0, 4, 4, 0, 5, 6, 0, 7, 8, 8]
[0, 1, 1, 2, 2, 3, 3, 0, 4, 4, 0, 5, 6, 0, 7, 8, 8]
[0, 1, 1, 2, 2, 3, 3, 4, 4, 4, 0, 5, 6, 0, 7, 8, 8]
[0, 1, 1, 2, 2, 3, 3, 4, 4, 4, 0, 5, 6, 7, 7, 8, 8]
[0, 1, 1, 2, 2, 3, 3, 4, 4, 4, 5, 5, 6, 7, 7, 8, 8]

```





## 시간 복잡도

-  `O(n)`의 갖는다.
  
  - 여기서 k는 가장 큰 자릿수를 나타낸다.
  
-  시간복잡도가 O(n)이면 완전 짧은데 왜 주로 사용되지 않을까?

   -  `Counting Sort`는 대부분의 상황에서 엄청난 `메모리 낭비`를 발생시킨다. 속도는 좋지만 메모리적 손실이 투마치 ㅠ.ㅠ😒

   - 그래서 MAX_NUM이 `특정 범위`로 확정되어 있을 때, 주로 사용한다!





#### 참고 자료

https://bowbowbow.tistory.com/8

https://www.codesdope.com/course/algorithms-count-and-sort/



